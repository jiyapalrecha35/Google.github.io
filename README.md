## Google's Algorithmic Rhythm: Exploring Smart Data Structures

<dl>
<dt>Course Name</dt>
<dd>Algorithmic Problem Solving</dd>
<dt>Course Code</dt>
<dd>23ECSE309</dd>
<dt>Name</dt>
<dd>Jiya Palrecha</dd>
<dt>SRN</dt>
<dd>01fe21bcs094</dd>
<dt>Course Instructor</dt>
<dd>Prakash Hegade</dd>
<dt>University</dt>
<dd>KLE Technological University, Hubballi-31</dd>
<dt>Portfolio Topic/Domain</dt>
<dd>Google</dd>

</dl>

<br>
> A stride towards enhanced Google service management.
>


<br>

This page hosts:

1. Introduction
2. Objectives/Need of Portfolio
3. Business Use Cases/Functionalities and the Corresponding Suggested Algorithms and Data Structures


## Introduction:
### Leveraging Data Structures and Algorithms in Google's Ecosystem

In today's digital age, the **efficiency** and **effectiveness** of technology services can be significantly enhanced through the strategic application of **data structures** and **algorithms**. This portfolio project delves into the core functionalities of Google's diverse services, applying the theoretical knowledge and practical skills acquired from courses in **Data Structures and Algorithms (DSA)** and **Algorithmic Problem Solving (APS)**.

By leveraging advanced algorithmic techniques and innovative data structures, this project aims to propose solutions to real-world business challenges. From refining search engine algorithms for improved relevance and speed to optimizing route planning in Google Maps, the potential for enhancement is vast.

This portfolio is a testament to the transformative power of algorithms within Google's ecosystem. Each **business use case** explored will demonstrate how thoughtful algorithmic problem-solving can streamline processes, enhance user experiences, and drive technological innovation. Join me in this exploration as we bridge the gap between theoretical knowledge and practical application, showcasing the profound impact of data structures and algorithms on modern digital services.

<br>


## Objectives/Need of Portfolio
1. Apply advanced algorithms and data structures to enhance the speed and efficiency of Google's services.
   
2. Demonstrate the real-world use of concepts learned in Data Structures and Algorithms (DSA) and Algorithmic Problem Solving (APS) courses.
   
3. Develop innovative solutions to improve user experiences and drive technological advancements within Google's ecosystem.
<br>


## Business Use Cases :


1. **Max Flow - Ford Fulkerson**: Algorithm for finding the maximum flow in a flow network, used in network flow optimization problems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/maxFlow.cpp){:target="_blank"}<br><br>
2. **Dijkstra's Algorithm**: Shortest path algorithm for finding the shortest paths between nodes in a weighted graph, often used in routing and navigation systems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/dijkstra.cpp){:target="_blank"}<br><br>
3. **Assignment Problem**: Optimization problem to determine the most efficient assignment of resources to tasks, commonly used in operations research and logistics planning. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/jobAssignment.cpp){:target="_blank"}<br><br>
4. **Min Query Segment Tree**: Data structure for efficiently finding the minimum value within a range of elements in an array, used in range query problems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/SegmentTree.cpp){:target="_blank"}<br><br>
5. **Trie for Auto Fetches**: Tree data structure used for efficient retrieval of keys in a dataset, often used in autocomplete and dictionary applications. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/Trie.cpp){:target="_blank"}<br><br>
6. **Fenwick Tree for Sum Query**: Data structure for efficiently computing prefix sums and answering range sum queries in an array, used in various applications including cumulative frequency tables. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/FenwickTree.cpp){:target="_blank"}<br><br>
7. **Persistent Segment Trees**: Data structure that allows for efficiently maintaining multiple versions of a dynamic array, used in problems requiring time travel or backtracking. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/PersistentSegmentTree.cpp){:target="_blank"}<br><br>
8. **Red-Black Trees**: Self-balancing binary search trees with guaranteed logarithmic time complexity for insertion, deletion, and search operations, commonly used in associative arrays and database indexing. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
9. **Rod Cutting Problem**: Optimization problem to maximize the value obtained by cutting a rod into pieces and selling them, used in resource allocation and inventory management. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
10. **Skip Lists**: Probabilistic data structure for maintaining a sorted list, providing efficient insertion, deletion, and search operations, used in fast search and indexing applications. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
11. **Edit Distance**: Dynamic programming algorithm for measuring the similarity between two strings by counting the minimum number of operations required to transform one string into the other, used in spell checking and DNA sequence alignment. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/editDistance.cpp){:target="_blank"}<br><br>
12. **Lookup Table**: Data structure for storing key-value pairs for efficient retrieval of values by keys, commonly used in database indexing and caching. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
13. **A* and Best First**: Search algorithms used for finding the shortest path or best solution in a graph or search space by intelligently prioritizing nodes based on heuristic information, commonly used in pathfinding and artificial intelligence. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
14. **Jump Game**: Algorithm for determining if it's possible to reach the last index of an array by jumping from index to index according to the values in the array, used in game development and optimization problems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
15. **KD Trees**: Data structure for organizing points in a k-dimensional space for efficient nearest neighbor search and range queries, used in geometric and spatial data analysis. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
16. **Topological Sort**: Graph algorithms for ordering the vertices of a directed graph such that for every directed edge uv, vertex u comes before vertex v, and for identifying strongly connected subgraphs in a directed graph, commonly used in task scheduling and dependency resolution. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/topoSort.cpp){:target="_blank"}<br><br>
17. **Conway's Game of Life**: Cellular automaton simulation for studying the evolution of patterns from initial configurations of cells according to simple rules, used in simulation studies and modeling complex systems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/conway.cpp){:target="_blank"}<br><br>
18. **Huffman Coding**: Lossless data compression algorithm for encoding variable-length symbols with variable-length codes based on their frequency of occurrence, used in file compression and transmission protocols. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/huffmann.cpp){:target="_blank"}<br><br>
19. **Traveling Salesman Problem (TSP)**: Combinatorial optimization problem to find the shortest possible route that visits each city exactly once and returns to the origin city, used in vehicle routing, logistics, and network design. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/tsp.cpp){:target="_blank"}<br><br>
20. **Knapsack Algorithms**: Optimization problems for selecting a subset of items to maximize value or minimize weight, used in resource allocation, budget planning, and inventory management. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
21. **Bridges/Articulation Points**: Graph algorithms for identifying critical edges or vertices whose removal would disconnect a graph or increase its number of connected components, used in network reliability analysis and fault tolerance. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
22. **Bloom Filters**: Probabilistic data structure for testing set membership with low memory footprint and constant time complexity, used in caching, spell checking, and network packet filtering. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
23. **Depth-First Search (DFS) and Breadth-First Search (BFS)**: Graph traversal algorithms for exploring or searching through graph or tree structures, used in network analysis, web crawling, and recommendation systems. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
24. **Hashing Algorithms**: Cryptographic techniques for generating fixed-size hash values from variable-size data, used in security protocols, data integrity checks, and authentication mechanisms. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/index){:target="_blank"}<br><br>
25. **Kruskal's Algorithm for MST**: Greedy algorithm for finding the minimum spanning tree (MST) of a connected, undirected graph. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/kruskalAlgoritm.c){:target="_blank"}<br><br>
26. **BST**: For data indexing, enabling efficient organization, search, and retrieval of data in different contexts. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/BST.c){:target="_blank"}<br><br>
27. **Strongly connected components**: For data indexing, enabling efficient organization, search, and retrieval of data in different contexts. [View code here](https://github.com/jiyapalrecha35/Google.github.io/blob/main/codes/SCC.cpp){:target="_blank"}<br><br>
